using System;
using System.Linq;
using WumpusCore.Topology;

// Everything that changes state should be protected
// Entity should be generated by Controller, initialized with a link to Topology, and given to GameLocations to store.
namespace WumpusCore.Entity
{
    /// <summary>
    /// Basic class for all entities to extend from. Contains all necessary movement options.
    /// </summary>
    public class Entity
    {
        // Entity's type
        public readonly EntityType Type;
        
        // Link to the GameLocations that spawned it
        protected readonly GameLocations.GameLocations gameLocations;
        
        // Location index in Topology
        public ushort location { get;  set; }

        // Given on initialization by Controller
        protected ITopology topologyLink;

        // The room this Entity is currently in
        protected IRoom thisRoom
        {
            get
            {
                return topologyLink.GetRoom(location);
            }
        }

        /// <summary>
        /// Create an Entity. Generic constructor that should never be run on its own.
        /// </summary>
        /// <param name="topology">The topology that this Entity traverses</param>
        /// <param name="parent">The GameLocations object that spawned this Entity</param>
        /// <param name="location">Starting topology room id</param>
        /// <param name="entityType">Type of this Entity</param>
        public Entity(ITopology topology, GameLocations.GameLocations parent, ushort location, EntityType entityType)
        {
            this.topologyLink = topology;
            this.Type = entityType;
            this.location = location;
            this.gameLocations = parent;
        }

        /// <summary>
        /// Gets all room indices adjacent to the room the Entity is currently in
        /// </summary>
        /// <returns>A list of integer indices of the adjacent rooms</returns>
        public ushort[] GetAdjacentRooms()
        {
            ushort[] results = new ushort[6];
            for (ushort i = 0; i < 6; i++)
            {
                results[i] = thisRoom.AdjacentRooms[(Directions)i].Id;
            }

            return results;
        }
        
        /// <summary>
        /// Gets all room indices adjacent to the room the Entity is currently in that can be traveled to in one move
        /// </summary>
        /// <returns>A list of integer indices of the accessible rooms</returns>
        public ushort[] GetAccessibleRooms()
        {
            ushort[] results = new ushort[thisRoom.ExitRooms.Count];
            for (ushort i = 0; i < results.Length; i++)
            {
                results[i] = thisRoom.ExitRooms[thisRoom.ExitDirections[i]].Id;
            }

            return results;
        }

        /// <summary>
        /// Checks if the given room is adjacent to this Entity
        /// </summary>
        /// <param name="roomIndex">The room that might be adjacent</param>
        /// <returns>True if the given room is adjacent, False otherwise</returns>
        public bool CheckIfAdjacent(ushort roomIndex)
        {
            return GetAdjacentRooms().Contains(roomIndex);
        }

        /// <summary>
        /// Checks if the given room is adjacent through a door to this Entity
        /// </summary>
        /// <param name="roomIndex">The room that might be accessible</param>
        /// <returns>True if the given room is accessible by a door, False otherwise</returns>
        public bool CheckIfAccessible(ushort roomIndex)
        {
            ushort[] accessibleRooms = GetAccessibleRooms();
            return accessibleRooms.Contains(roomIndex);
        }

        /// <summary>
        /// Get the room in a direction from the current room
        /// </summary>
        /// <param name="direction">The door/wall to check through</param>
        /// <returns>The index of the room in the given direction</returns>
        public ushort GetRoomInDirection(Directions direction)
        {
            return thisRoom.AdjacentRooms[direction].Id;
        }

        /// <summary>
        /// Tries to move to the given room, throws an exception if not possible
        /// </summary>
        /// <param name="roomIndex">The room to move to</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the given room is not accessible</exception>
        protected void MoveToRoom(ushort roomIndex)
        {
            if (!CheckIfAccessible(roomIndex))
            {
                throw new ArgumentOutOfRangeException("Room not accessible!");
            }
            TeleportToRoom(roomIndex);
        }

        /// <summary>
        /// Forces a move to the given room.
        /// </summary>
        /// <param name="roomIndex">The room index to move to</param>
        protected void TeleportToRoom(ushort roomIndex)
        {
            this.location = roomIndex;
        }

        /// <summary>
        /// Moves once in a random direction.
        /// </summary>
        protected void MoveToRandomAdjacent()
        {
            ushort[] accessibleRooms = GetAccessibleRooms();
            MoveToRoom(accessibleRooms[Controller.Controller.Random.Next(0, accessibleRooms.Length)]);
        }

        /// <summary>
        /// Teleports to a random room on the map.
        /// </summary>
        protected void TeleportToRandom()
        {
            TeleportToRoom((ushort)Controller.Controller.Random.Next(0, topologyLink.RoomCount));
        }

        /// <summary>
        /// Returns True if the given Entity is in the same room as this Entity, False otherwise
        /// </summary>
        /// <param name="e">The entity that might be in the same room</param>
        public bool CheckIfEntitySharingRoom(Entity e)
        {
            return (e.location == this.location);
        }

        /// <summary>
        /// Checks if the given Entity is in a room that is adjacent to the room this Entity is in. (distance == 1)
        /// </summary>
        /// <param name="e">The entity that might be adjacent to this Entity</param>
        /// <returns>True if the given Entity is in a room adjacent to the current room, False if otherwise, even if they are in the same room.</returns>
        public bool CheckIfEntityAdjacent(Entity e)
        {
            return CheckIfAdjacent(e.location);
        }

        /// <summary>
        /// Finds how many moves it would take for this Entity to move to the given roomIndex
        /// </summary>
        /// <param name="roomIndex">The room to navigate to</param>
        /// <returns>Distance (in accessible rooms) to the given room</returns>
        public int AccessibleDistanceToRoom(ushort roomIndex)
        {
            return topologyLink.DistanceBetweenRooms(this.location, roomIndex, Topology.Topology.NavigateDoors);
        }

        /// <summary>
        /// Finds how many moves it would take for this Entity to move to the given Entity
        /// </summary>
        /// <param name="e">The Entity to navigate to</param>
        /// <returns>Distance (in accessible rooms) to the given Entity</returns>
        public int AccessibleDistanceToEntity(Entity e)
        {
            return AccessibleDistanceToRoom(e.location);
        }



        /// <summary>
        /// Finds the distance in rooms to the given roomIndex, ignoring walls, doors, and obstacles.
        /// </summary>
        /// <param name="roomIndex">The room to find the distance to</param>
        /// <returns>The distance to the given room</returns>
        public int DistanceToRoom(ushort roomIndex)
        {
            return topologyLink.DistanceBetweenRooms(this.location, roomIndex, Topology.Topology.NavigateBoundless);
        }
        
        /// <summary>
        /// Finds the distance in rooms to the given Entity, ignoring walls, doors, and obstacles.
        /// </summary>
        /// <param name="e">The Entity to find the distance to</param>
        /// <returns>The distance to the given Entity</returns>
        public int DistanceToEntity(Entity e)
        {
            return DistanceToRoom(e.location);
        }
    }
}